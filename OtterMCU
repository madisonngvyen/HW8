`timescale 1ns / 1ps

module OtterMCU(
    input RST,
    input intr,                 // debounced interrupt input from wrapper
    input [31:0] iobus_in,
    input clk,
    output  [31:0] iobus_out ,
    output [31:0] iobus_addr,
    output iobus_wr  
    );

    // existing control/datapath wires
    wire pc_we, rf_we, memwe2, memrden1, memrden2, reset, srca_sel, br_eq, br_lt, br_ltu;
    wire [1:0] srcb_sel,pc_sel, rf_sel;
    wire [3:0] alu_fun; 
    wire [31:0] jalr,branch,jal,pc_data,ir,j_type,b_type,u_type,i_type,s_type,rs,mux_out,rs1,rs2,srcA, srcB,result,dout2,w_data;

    // --------------------------
    // NEW: CSR / interrupt wires
    // --------------------------
    wire        csr_en;
    wire [2:0]  csr_op;
    wire        mret;
    wire [11:0] csr_addr   = ir[31:20];  // standard CSR address field
    wire [31:0] csr_wdata  = rs1;        // RS1 value is source for CSRRW/CSRRS/CSRRC
    wire [31:0] csr_rdata;

    wire        take_intr;
    wire        mret_exec;
    wire [31:0] csr_pc;
    wire        pc_from_csr;
    wire        mie_en;

    // Interrupt request should only be honored when MSTATUS.MIE==1
    wire intr_req = intr & mie_en;

    // --------------------------
    // CU (FSM + Decoder)
    // --------------------------
    CU_FSM my_fsm(
        .intr     (intr_req),        // <- use gated irq
        .clk      (clk),
        .RST      (RST),
        .opcode   (ir[6:0]),
        .mret     (mret),            // <- from decoder

        .PC_WE    (pc_we),
        .RF_WE    (rf_we),
        .memWE2   (memwe2),
        .memRDEN1 (memrden1),
        .memRDEN2 (memrden2),
        .reset    (reset),

        .take_intr(take_intr),       // <- to CSR
        .mret_exec(mret_exec)        // <- to CSR
    );

    CU_DCDR my_cu_dcdr(
       .br_eq     (br_eq), 
       .br_lt     (br_lt), 
       .br_ltu    (br_ltu),
       .opcode    (ir[6:0]),    
       .func7     (ir[30]),    
       .func3     ( ir[14:12] ),    
       .ALU_FUN   (alu_fun),
       .PC_SEL    (pc_sel),
       .srcA_SEL  (srca_sel),
       .srcB_SEL  (srcb_sel), 
       .RF_SEL    (rf_sel),

       // NEW decoder outputs (you already added these in your WIP file)
       .csr_en    (csr_en),
       .csr_op    (csr_op),
       .mret      (mret)
    );

    // --------------------------
    // PC next selection (unchanged)
    // --------------------------
    wire [31:0] pc_next_normal;
    mux_4t1_nb  #(.n(32)) my_4t1_mux  (
        .SEL   (pc_sel), 
        .D0    (pc_data + 4), 
        .D1    (jalr), 
        .D2    (branch), 
        .D3    (jal),
        .D_OUT (pc_next_normal) );

    // --------------------------
    // NEW: PC override from CSR
    // If pc_from_csr=1, load mtvec (on irq) or mepc (on mret)
    // --------------------------
    wire [31:0] pc_next_final;
    mux_2t1_nb #(.n(32)) pc_override_mux (
        .SEL   (pc_from_csr),     // 1 => use csr_pc
        .D0    (pc_next_normal),
        .D1    (csr_pc),
        .D_OUT (pc_next_final)
    );

    reg_nb_sclr #(.n(32)) PC (
       .data_in  (pc_next_final), 
       .ld       (pc_we), 
       .clk      (clk), 
       .clr      (reset), 
       .data_out (pc_data));  

    // --------------------------
    // Register writeback mux
    // Keep your 4-way. For CSRs we'll reuse D2's slot (normally loads)
    // by putting a small pre-mux in front of it: D2 = (csr_en ? csr_rdata : MEM_DOUT2)
    // --------------------------
    wire [31:0] d2_load_or_csr = (csr_en) ? csr_rdata : dout2;

    mux_4t1_nb  #(.n(32)) Reg_Mux (
       .SEL   (rf_sel), 
       .D0    (pc_data + 4), 
       .D1    (32'h00000000), 
       .D2    (d2_load_or_csr),     // <- was dout2
       .D3    (result),
       .D_OUT (w_data) );       

    // Memory unchanged
    Memory OTTER_MEMORY ( 
        .MEM_CLK    (clk), 
        .MEM_RDEN1  (memrden1),  
        .MEM_RDEN2  (memrden2),  
        .MEM_WE2    (memwe2), 
        .MEM_ADDR1  (pc_data[15:2]), 
        .MEM_ADDR2  (result), 
        .MEM_DIN2   (rs2),
        .MEM_SIZE   (ir[13:12]), 
        .MEM_SIGN   (ir[14]), 
        .IO_IN      (iobus_in), 
        .IO_WR      (iobus_wr), 
        .MEM_DOUT1  (ir), 
        .MEM_DOUT2  (dout2)  );        
        
    RegFile my_regfile (
        .w_data (w_data),
        .clk    (clk), 
        .en     (rf_we),
        .adr1   (ir[19:15]),
        .adr2   (ir[24:20]),
        .w_adr  (ir[11:7]),
        .rs1    (rs1), 
        .rs2    (rs2)  );
    
    IMMED_GEN IG (
        .ir     (ir),
        .J_type (j_type),
        .B_type (b_type),
        .U_type (u_type),
        .I_type (i_type),
        .S_type (s_type) );     
    
    mux_2t1_nb  #(.n(32)) my_2t1_mux  (
       .SEL   (srca_sel), 
       .D0    (rs1), 
       .D1    (u_type), 
       .D_OUT (srcA) );
       
    BRANCH_COND_GEN bcg (
       .rs1   (rs1), 
       .rs2   (rs2), 
       .br_eq (br_eq), 
       .br_lt (br_lt), 
       .br_ltu(br_ltu));                  
 
    mux_4t1_nb  #(.n(32)) my_4t1_mux2  (
       .SEL   (srcb_sel), 
       .D0    (rs2), 
       .D1    (i_type), 
       .D2    (s_type), 
       .D3    (pc_data),
       .D_OUT (srcB) );                    
    
    alu  my_alu (
        .alu_fun  (alu_fun),
        .srcA     (srcA),
        .srcB     (srcB),
        .result   (result)
    );    

    BRANCH_ADDR_GEN BAG ( 
        .J_type  (j_type),
        .pc      (pc_data),
        .B_type  (b_type),
        .rs      (rs1),
        .I_type  (i_type),
        .jalr    (jalr),
        .jal     (jal),
        .branch  (branch) ); 

    // --------------------------
    // NEW: CSR block
    // --------------------------
    CSR_File CSR (
        .clk        (clk),
        .rst        (reset),

        .csr_en     (csr_en),
        .csr_op     (csr_op),
        .csr_addr   (csr_addr),
        .csr_wdata  (csr_wdata),
        .csr_rdata  (csr_rdata),

        .take_intr  (take_intr),
        .mret_exec  (mret_exec),
        .pc_curr    (pc_data),    // save current PC on interrupt
        .csr_pc     (csr_pc),     // mtvec or mepc
        .pc_from_csr(pc_from_csr),
        .mie_en     (mie_en)
    );

    // I/O bus unchanged
    assign iobus_addr = result;
    assign iobus_out  = rs2;

endmodule
